Day 2 notes

http://konf.me/pdp

ildasm.exe 

code smells
	primitive obsession 
		-> when we use a primitive type (e.g., integer) instead of a 
		-> refactoring is to introduce proper abstractions 
 
	complex method 
		-> moment it crosses certain cyclomatic complexity limit 
	
design smell 
	needless null check!!  
		-> Missing abstraction 
		-> Constant object, that is not needed anymore 

	switch based on type 
		-> "Missing hierarchy"
		-> replaced with runtime polymorphism 
 
	complex object creation smell 
		-> somewhat simplified because of domain abstractions
 		
Arch smell 
	procedural design -> can I mechanically translate this into C code -> answer is Yes 

Original Expression: 

	// ((10 * 20) + 30) 
	var expr = new Expr(
                new Expr(
                    new Expr(null, "10", null), "*", new Expr(null, "20", null)),
                "+",
                new Expr(null, "30", null));

Step 1 (somewhat better): 

	var exprNode = new Plus(
                new Multiply(
                    new Constant(10),
                    new Constant(20)),
                new Constant(30));

Step 2 : 

var exprNode = Plus.Make(
                Multiply.Make(
                    Constant.Make(10),
                    Constant.Make(20)),
                Constant.Make(30));
// factory methods 
// controlling or limiting object creation 
// provides basis for further design improvements and simplifications, 
// including builder, flyweight, fluent interfaces, etc 

Final step: 

((10 * 20) + 30)

ten.multipledBy(twenty).plus(thirty) 

// fluent interfaces
// we are dealing with domain language 
// for endusers- programmers  

An expression tree consists of expression nodes. The nodes can be operators or constants. 


enum FileElementType {
	Folder, File, Shortcut 
	} 

class BinaryExprNode : ExprNode
    {
        private readonly IList<ExprNode> elements;


Composite pattern 

Signature 
	Class that is dervied from its base type and has objects of its base type








